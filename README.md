# Rock, Paper, Scissors
 
Creating a rock, paper, scissors game in a different programming language...
everyday... for all of eternity.

## Resources

Before we get started, special thanks to the following:

- http://rosettacode.org/
- https://esolangs.org/
- http://stackoverflow.com/

## Dear God, Why?

Because learning. S'why.

### But... Why Rock, Paper, Scissors?

Hello world is boring.

Fizz buzz is played out.

Rock, Paper, Scissors, on the other hand, has a little bit of everything,
making it a perfect learning opportunity for developers at any level. Typical
features include:

- Loops
- Input
- Validation
- Output
- Randomization
- Conditionals

## Contributing

Want to contribute to our little project? Take a look at some of our existing
examples, take a crack at any language, and submit a pull request.

We are by no means experts, so if you see something that can be improved upon,
please let us know (or submit a pull request with the changes yourself)!

### Functionality

We haven't exactly established many rules, but here are some guidelines that we
are trying to adhere pretty strictly to with each implementation:

- The game should continue until either the player or the computer wins. That means an infinite loop.
    - The player should be able to choose between rock, paper, and scissors with any case and any leading/trailing whitespace (hint: use a case-insensitive comparison and trim the input).
    - The computer should randomly choose between rock, paper, and scissors.
    - The winner should be determined by the rules of the game: rock beats scissors, scissors beats paper, and paper beats rock.
    - The player should be prompted to enter their choice by the printed message `Your Move: `.
    - If the player enters an invalid choice, the program should repeat the prmpt until a valid choice is entered.
    - If the player wins, the program should print `You Win!` and exit.
    - If the computer wins, the program should print `Computer Wins!` and exit.
    - If it's a tie, the program should print `Tie, Replay!` and continue the game.
- Implement command line applications, unless explicitly impossible due to language constraints (i.e. CSS/HTML/Scratch/etc).
- Unless it is absolutely, 100% necessary (it shouldn't be), do not use third-party libraries or packages. Try to use standard libraries whenever possible.
- Every language should have a README file explaining (or at least pointing to an official resource explaining) how to install, compile, and run the source.
- If the language is not yet represented, create a new directory with the language name in lowercase and add your implementation there (i.e. `c/`, `python/`, `ruby/`, etc).
- If the language is already represented, add your implementation to the existing directory.
- All implementations should be in the form of a single file named `rps.ext`, where `ext` is the file extension for the language. If the language does not have a standard file extension, use the most common one.

### README

Every language should have a README file explaining (or at least pointing to
a resource explaining) how to install, compile, and run the source.

## List of Potential Languages

- ACL2
- Acurity Architect
- Ada
- Aikido
- ALGOL
- AmigaE
- Assembly
- ~~AppleScript~~
- Arbre
- Argile
- ATS
- AutoHotkey
- AutoIt
- Axiom
- AWK
- ~~Bash~~
- Batch
- bc
- Befunge
- BlitzMax
- Bracmat
- Burlesque
- ~~C~~
- ~~C++~~
- C#
- C1R
- Caché ObjectScript
- Ceylon
- Clarion
- CLIPS
- Clojure
- COBOL
- Coco
- CoffeeScript
- ColdFusion
- ~~Commodore BASIC~~
- Common Lisp
- Component Pascal
- Coq
- Crystal
- D
- Dart
- DCL
- Delphi
- Déjà Vu
- DWScript
- Dylan
- EchoLisp
- ECL
- Eero
- EGL
- Eiffel
- Ela
- Elena
- Elixir
- ERRE
- Euphoria
- F#
- Factor
- Falcon
- Fantom
- FBSL
- ~~Fortran~~
- Forth
- Frink
- FunL
- GAP
- GML
- ~~Go~~
- Golfscript
- Gosu
- Groovy
- Harbour
- Haskell
- Haxe
- HicEst
- Hy
- Icon
- Inform 7
- Informix 4GL
- Io
- Ioke
- J
- Java
- ~~JavaScript~~
- jq
- Julia
- K
- Kotlin
- Lasso
- Lhogho
- Lily
- Lisp
- LiveCode
- Logo
- LOLCODE
- Lua
- M4
- Maple
- Mathematica
- MATLAB
- Maxima
- MAXScript
- Mercury
- Metafont
- Mirah
- mIRC Scripting Language
- ML/I
- MMIX
- Modula-2
- Modula-3
- MOO
- MoonScript
- MUMPS
- NetRexx
- Nim
- ~~Node.js~~
- Objeck
- Objective-C
- OCaml
- Octave
- Oforth
- ooRexx
- OpenEdge
- OxygenBasic
- Oz
- PARI/GP
- Pascal
- ~~Perl~~
- Phix
- PHL
- ~~PHP~~
- Pike
- PL/I
- PL/SQL
- Pop11
- PostScript
- Potion
- PowerShell
- ProDOS
- Prolog
- Python
- Q
- R
- Racket
- RapidQ
- REBOL
- Retro
- REXX
- ~~Ruby~~
- Rust
- S-lang
- Salmon
- SAS
- Scala
- Sather
- Scheme
- Seed7
- SETL
- Sidef
- Slate
- Smalltalk
- SNOBOL4
- Sparkling
- SQL
- Swift
- Tcl
- TI-83 BASIC
- TI-89 BASIC
- TorqueScript
- TSE SAL
- TUSCRIPT
- TXR
- Uniface
- Ursala
- Vala
- VBA
- VBScript
- VHDL
- Visual Basic .NET
- Visual C++
- Wart
- Wortel
- Wrapl
- XPL0
- XSLT 1.0
- XSLT 2.0
- Yorick
- zkl
